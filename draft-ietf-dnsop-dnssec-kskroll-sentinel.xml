<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<rfc category="std" docName="draft-ietf-dnsop-kskroll-sentinel-13"
     ipr="trust200902">
  <front>
    <title abbrev="DNSSEC Trusted Key Sentinel">A Root Key Trust Anchor
    Sentinel for DNSSEC</title>

    <author fullname="Geoff Huston" initials="G." surname="Huston">
      <organization abbrev="APNIC"/>

      <address>
        <email>gih@apnic.net</email>

        <uri>http://www.apnic.net</uri>
      </address>
    </author>

    <author fullname="Joao Silva Damas" initials="J." surname="Damas">
      <organization abbrev="APNIC"/>

      <address>
        <email>joao@apnic.net</email>

        <uri>http://www.apnic.net</uri>
      </address>
    </author>

    <author fullname="Warren Kumari" initials="W." surname="Kumari">
      <organization abbrev="Google"/>

      <address>
        <email>warren@kumari.net</email>
      </address>
    </author>

    <date day="1" month="June" year="2018"/>

    <area>Internet</area>

    <workgroup>DNSOP</workgroup>

    <abstract>
      <t>The DNS Security Extensions (DNSSEC) were developed to provide origin
      authentication and integrity protection for DNS data by using digital
      signatures. These digital signatures can be verified by building a chain
      of trust starting from a trust anchor and proceeding down to a
      particular node in the DNS. This document specifies a mechanism that
      will allow an end user and third parties to determine the trusted key
      state for the root key of the resolvers that handle that user's DNS
      queries. Note that this method is only applicable for determining which
      keys are in the trust store for the root key.</t>

      <t>[ This document is being collaborated on in Github at:
      https://github.com/APNIC-Labs/draft-kskroll-sentinel. The most recent
      version of the document, open issues, etc should all be available here.
      The authors (gratefully) accept pull requests. RFC Editor, please remove
      text in square brackets before publication. ]</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>The DNS Security Extensions (DNSSEC) <xref target="RFC4033"/>, <xref
      target="RFC4034"/> and <xref target="RFC4035"/> were developed to
      provide origin authentication and integrity protection for DNS data by
      using digital signatures. DNSSEC uses Key Tags to efficiently match
      signatures to the keys from which they are generated. The Key Tag is a
      16-bit value computed from the RDATA portion of a DNSKEY RR using a
      formula found in "Key Tag Calculation" (Appendix B of "Resource Records
      for the DNS Security Extensions" <xref target="RFC4034"/>), a formula
      similar to a ones-complement checksum. RRSIG RRs contain a Key Tag field
      whose value is equal to the Key Tag of the DNSKEY RR that validates the
      signature.</t>

      <t>This document specifies how validating resolvers can respond to
      certain queries in a manner that allows a querier to deduce whether a
      particular key for the root has been loaded into that resolver's trusted
      key store. In particular, this response mechanism can be used to
      determine whether a certain root zone KSK is ready to be used as a
      trusted key, within the context of a planned root zone KSK key roll, by
      this resolver.</t>

      <t>There are two primary use cases for this mechanism:</t>

      <t><list style="symbols">
          <t>Users want to know whether the resolvers they use are ready for
          an upcoming root KSK rollover</t>

          <t>Researchers want to perform Internet-wide studies about the
          percentage of users who will be ready for an upcoming root KSK
          rollover</t>
        </list></t>

      <t>The mechanism described in this document meets both of these use
      cases. This new mechanism is OPTIONAL to implement and use, although for
      reasons of supporting broad-based measurement techniques, it is strongly
      preferred that configurations of DNSSEC-validating resolvers enabled
      this mechanism by default, allowing for local configuration directives
      to disable this mechanism if desired.</t>

      <t>The sentinel test described in this document determines whether a
      user's browser or operating system looking up the special names that are
      used in this protocol would be able to validate using the root KSK
      indicated by the special names. The protocol uses the DNS SERVFAIL
      response code (RCODE 2) for this purpose because that is the response
      code that is returned by resolvers when DNSSEC validation fails.</t>
      
      <t>If a browser or operating system is configured with multiple
      resolvers, and those resolvers have different properties (for
      example, one performs DNSSEC validation and one does not), the
      sentinel test described in this document can still be used, but
      it makes a number of assumptions about DNS resolution behaviour
      that may not necessarily hold in all environments. If these
      assumptions do not hold (such as, for example, requring the stub
      resolver to query the next recursive resolver in the locally
      configured set upon receipt of a SERVFAIL response code) then
      this test may produce indeterminate or onconsistent results. In
      some cases where these assumptions do not hold, running the same
      test twice in succession may generate different results.</t>

      <t>Note that the sentinel mechanism described here measures a
      very different (and likely more useful) metric than <xref
      target="RFC8145"/>.  RFC 8145 relies on resolvers reporting
      towards the root servers a list of locally cached trust anchors
      for the root zone. Those reports can be used to infer how many
      resolvers may be impacted by a KSK roll, but not what the user
      impact of the KSK roll will be.</t>

      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in RFC 2119.</t>
      </section>
    </section>

    <section title="Sentinel Mechanism in Resolvers" anchor="sent_mech_in_resolvers">
      <t>DNSSEC-Validating resolvers that implement this mechanism
      MUST perform validation of responses in accordance with the
      DNSSEC response validation specification <xref
      target="RFC4035"/>.</t>

      <t>This sentinel mechanism makes use of two special labels:<list
          style="symbols">
          <t>root-key-sentinel-is-ta-&lt;key-tag&gt;</t>

          <t>root-key-sentinel-not-ta-&lt;key-tag&gt;</t>
        </list> Note that the &lt;key-tag&gt; is specified in the DNS label as
      unsigned decimal integer (as described in <xref target="RFC4034"/>,
      section 5.3), but zero-padded to five digits (for example, a Key Tag
      value of 42 would be represented in the label as 00042).</t>

      <t>These labels trigger special processing in the validating DNS resolver when
      responses from authoritative servers are received. Labels containing
      "root-key-sentinel-is-ta-&lt;key-tag&gt;" is used to answer the question
      "Is this the Key Tag of a key which the validating DNS resolver is
      currently trusting as a trust anchor?" Labels containing
      "root-key-sentinel-not-ta-&lt;key-tag&gt;" is used to answer the
      question "Is this the Key Tag of a key which the validating DNS resolver
      is *not* currently trusting as a trust anchor?"</t>

      <section anchor="precond" title="Preconditions">
        <t>All of the following conditions must be met to trigger special
        processing inside resolver code: <list style="symbols">
            <t>The DNS response is DNSSEC validated.</t>

            <t>The result of validation is "Secure".</t>

            <t>The Checking Disabled (CD) bit in the query is not set.</t>

            <t>The QTYPE is either A or AAAA (Query Type value 1 or 28).</t>

            <t>The OPCODE is QUERY.</t>

            <t>The leftmost label of the original QNAME (the name sent in the
            Question Section in the original query) is either
            "root-key-sentinel-is-ta-&lt;key-tag&gt;" or
            "root-key-sentinel-not-ta-&lt;key-tag&gt;".</t>
          </list></t>

        <t>If any one of the preconditions is not met, the resolver MUST NOT
        alter the DNS response based on the mechanism in this document.</t>
      </section>

      <section title="Special Processing">
        <t>Responses which fulfil all of the preconditions in <xref
        target="precond"/> require special processing, depending on leftmost
        label in the QNAME.</t>

        <t>First, the resolver determines if the numerical value of
        &lt;key-tag&gt; is equal to any of the Key Tag values of an active
        root zone KSK which is currently trusted by the local resolver and is
        stored in its store of trusted keys. An active root zone KSK is one
        which could currently be used for validation (that is, a key that is
        not in either the AddPend or Revoked state as described in <xref
        target="RFC5011"/>).</t>

        <t>Second, the resolver alters the response being sent to the original
        query based on both the left-most label and the presence of a key with
        given Key Tag in the trust anchor store. Two labels and two possible
        states of the corresponding key generate four possible combinations
        summarized in the table:</t>

        <t><figure>
            <artwork><![CDATA[
 Label      | Key is trusted          | Key is not trusted
 ------------------------------------------------------------------
 is-ta      | return original answer  | return SERVFAIL
 not-ta     | return SERVFAIL         | return original answer
]]></artwork>
          </figure></t>

        <t>Instruction "return SERVFAIL" means that the resolver MUST set
        RCODE=SERVFAIL (value 2) and the ANSWER section of the DNS response
        MUST be empty, ignoring all other documents which specify content of
        the ANSWER section.</t>
      </section>
    </section>

    <section title="Sentinel Tests for a Single DNS Resolver" anchor="single_resolver">

      <t>This section describes the use of the sentinel detection
      mechanism against a single DNS recursive resolver in order to
      determine whether or not this resolver is using a locally cached
      particular trust anchor to validate DNSSEC-signed responses.</t>
      
      <t>Note that this test is applicable for a single DNS
      resolver. The case of using this sentinel mechanism to test the
      trust anchor capabilities of a collection of resolvers, as might
      be found in the DNS configuration of an end-user environment, is
      described in <xref target="resolver_sets"/>.</t>

      <t>The critical aspect of the DNS names used in this mechanism
      is that they contain the specified label for either the positive
      and negative test as the left-most label in the query name.</t>

      <t>The sentinel detection procedure test a DNS resolver using
      three queries:</t>

      <t><list style="symbols">
          <t>A query name containing the left-most label
          "root-key-sentinel-is-ta-&lt;key-tag&gt;". This corresponds to a a
          validly-signed RRset in the zone, so that responses associated with
          queried names in this zone can be authenticated by a
          DNSSEC-validating resolver. Any validly-signed DNS zone can be used
          for this test.</t>

          <t>A query name containing the left-most label
          "root-key-sentinel-not-ta-&lt;key-tag&gt;". This is also a
          validly-signed name. Any validly-signed DNS zone can be used for
          this test.</t>

          <t>A query name that is signed with a DNSSEC signature that cannot
          be validated (described as a "bogus" RRset in Section 5 of <xref
          target="RFC4033"/>, when, for example, an RRset is not signed with a
          valid RRSIG record).</t>
        </list></t>

      <t>The responses received from queries to resolve each of these
      names can be evaluated to infer a trust key state of the DNS
      resolver.</t>

      <t>An essential assumption here is that this technique relies on
      security-aware (DNSSEC validating) resolvers responding with a
      SERVFAIL response code to queries where DNSSEC checking is
      requested and the response cannot be validated. Note that a
      slew of other issues can also cause SERVFAIL responses, and so
      the sentinel processing may sometimes result in incorrect or
      indeterminate conclusions.</t>

      <t>To describe this process of classification, we can classify
      DNS resolvers into five distinct behavior types, for which we
      will use the labels: "Vnew", "Vold", "Vind", "nonV", and
      "other". These labels correspond to resolver system behaviour
      types as follows:</t>

      <t><list style="hanging">
          <t hangText="Vnew:">A DNS resolver that is configured to
          implement this mechanism and has loaded the nominated key
          into their local trusted key stores will respond with an A
          or AAAA RRset response for the associated
          "root-key-sentinel-is-ta" queries, SERVFAIL for
          "root-key-sentinel-not-ta" queries and SERVFAIL for the
          signed name queries that return "bogus" validation
          status.</t>

          <t hangText="Vold:">A DNS resolver that is configured to
          implement this mechanism and has not loaded the nominated
          key into their local trusted key stores will respond with an
          SERVFAIL for the associated "root-key-sentinel-is-ta"
          queries, an A or AAAA RRset response for
          "root-key-sentinel-not-ta" queries and SERVFAIL for the
          signed name queries that return "bogus" validation
          status.</t>

          <t hangText="Vind:">A DNS resolver that has is not
          configured to implement this mechanism will respond with an
          A or AAAA RRset response for "root-key-sentinel-is-ta", an A
          or AAAA RRset response for "root-key-sentinel-not-ta" and
          SERVFAIL for the name that returns "bogus" validation
          status.  This set of responses does not give any information
          about the trust anchors used by this resolver.</t>

          <t hangText="nonV:">A non-security-aware DNS resolver will
          respond with an A or AAAA record response for
          "root-key-sentinel-is-ta", an A record response for
          "root-key-sentinel-not-ta" and an A or AAAA RRset response
          for the name that returns "bogus" validation status.</t>
          
          <t hangText="other:">There is the potential to admit other
          combinations of responses to these three queries. While this
          may appear self-contradictory, there are cases where such an
          outcome is possible. For example, in DNS resolver farms what
          appears to be a single DNS resolver that responds to queries
          passed to a single IP address is in fact constructed as a a
          collection of slave resolvers, and the query is passed to
          one of these internal resolver engines. If these individual
          slave resolvers in the farm do not behave identically, then
          other sets of results can be expected from these three
          queries. In such a case, no determination about the
          capabilities of this DNS resolver farm can be made.</t>
          </list></t>

      <t>Note that SERVFAIL might be cached according to Section 7 of <xref
      target="RFC2308"/> for up to 5 minutes and a positive answer
      for up to its TTL.</t>

      <t>If a client directs these three queries to a single resolver,
      the responses should allow the client to determine the
      capability of the resolver, and if it supports this sentinel
      mechanism, whether or not it has a particular key in its trust
      anchor store, as in the following table:</t>

      <t><figure>
          <artwork><![CDATA[
                                 Query
                   +----------+-----------+------------+
                   |  is-ta   |  not-ta   |   bogus    |
           +-------+----------+-----------+------------+
           | Vnew  |    A     |  SERVFAIL |  SERVFAIL  |
           | Vold  | SERVFAIL |      A    |  SERVFAIL  |
     Type  | Vind  |    A     |      A    |  SERVFAIL  |
           | nonV  |    A     |      A    |     A      |
           | other |    *     |      *    |     *      |
           +-------+----------+-----------+------------+
  ]]></artwork>
        </figure></t>

      <t><list style="hanging">
          <t hangText="Vnew:">The nominated key is trusted by the
          resolver.</t>

          <t hangText="Vold:">The nominated key is not yet trusted by the
          resolver.</t>

          <t hangText="Vind:">There is no information about the trust
          anchors of the resolver.</t>

          <t hangText="nonV:">The resolver does not perform DNSSEC
          validation.</t>

          <t hangText="nonV:">The properties of the resolver cannot be
          analyzed by this protocol.</t> 
      </list></t>


      <section title="Forwarders">

        <t>There is also the common case of a recursive resolver using
        a forwarder.</t>

        <t>If the resolver is non-validating, and it has a single
        forwarder, then the resolver will presumably mirror the
        capabilities of the forwarder target resolver.</t>

        <t>If the validating resolver has a forwarding configuration,
        and uses the CD bit on all forwarded queries, then this
        resolver is acting in a manner that is identical to a
        standalone resolver.</t>

        <t>A more complex case is where all of the following
        conditions hold:

        <list style="symbols">
          <t>Both the validating resolver and the forwarder target
          resolver support this trusted key sentinel mechanism</t>

          <t>The local resolver's queries do not have the CD bit set</t>

          <t>The trusted key state differs between the forwarding resolver and
          the forwarder target resolver</t>

        </list> In such a case, either the outcome is indeterminate
        validating ("Vind"), or a case of mixed signals such as
        SERVFAIL in all three responses, ("other") which is similarly
        an indeterminate response with respect to the trusted key
        state.</t>

      </section>

    </section>

    <section title="Sentinel Tests for a set of Resolvers" anchor="resolver_sets">
      <t>The description in <xref target="single_resolver"/> describes
      a trust anchor test that can be used in the simple situation
      where the test queries were being passed to a single recursive
      resolver that directly queries authoritative name servers.</t>

      <t>However, the common end user scenario is where a user's local
      DNS resolution environment is configured to use a set of
      recursive resolvers. The single resolver test technique will not
      function reliably in such cases, as a a SERVFAIL response from
      one resolver may cause the local stub resolver to repeat the
      query against one of the other configured resolvers and the
      results may be inconclusive.</t>

      <t>In describing a test procedure that can be used in this
      environment of a set of DNS resolvers there are some necessary
      changes to the nature of the question that this test can answer,
      the assumptions about the behaviour of the DNS resolution
      environment, and some further observations about potential
      variability in the test outcomes.</t>

      <section title="Test Scenario and Objective">

        <t>This test is not intended to expose which trust anchors are
        used by any individual DNS resolver.</t>

        <t>The test scenario is explicitly restricted to that of the
        KSK environment where a current active KSK, namely
        "KSK-current" is to be replaced with "KSK-new".</t>

        <t>The timing of the test is intended to be undertaken in the
        period between the original introduction of KSK-new into the
        root zone and the point of the KSK roll when KSK-current is
        removed from the root zone.</t>

        <t>The objective of the test is to determine if the user will
        be negatively impacted by the KSK roll. A "negative impact"
        for the user is defined such that all the configured resolvers
        are security-aware resolvers that perform validation of
        DNSSEC-signed responses, and none of these resolvers have
        loaded KSK-new into their local trust anchor set. In this
        situation it is anticipated that once the KSK is rolled the
        entire set of the user's resolvers will not be able to
        validate the contents of the root zone and the user is likely
        to loose DNS service as a result of this inability to perform
        successful DNSSEC validation.</t>

      </section>
    
      <section title="Test Assumptions">

        <t>There are a number of assumptions about the DNS environment
        used in this test. Where these assumptions do not hold the
        results of the test will be indeterminate.</t>

        <t><list style="symbols">

          <t>When the user's stub resolver passes a query to a
          resolver in the configured resolver set, it will get a
          consistent answer over the timeframe of the queries. This
          assumption implies that if the same query is asked by the
          same stub resolver multiple times in succession to the same
          recursive resolver, the recursive resolver's response will
          be the same for each of these queries.</t>
 
          <t>All DNSSEC-validating resolvers have KSK-current in their
          local trust anchor cache.</t>

          <t>When a recusrive resolver returns SERVFAIL the user's
          stub resolver will re-query using the next resolver in the
          locally configured resolver set.</t>
        </list></t>

      </section>

      <section title="Test Procedure">

        <t>The sentinel detection process test a DNS resolution
        environment with three query names:</t>

        <t><list style="symbols">

          <t>A query name that is signed with a DNSSEC signature that cannot
          be validated (described as a "bogus" RRset in Section 5 of <xref
          target="RFC4033"/>, when, for example, an RRset is not signed with a
          valid RRSIG record).</t>

          <t>A query name containing the left-most label
          "root-key-sentinel-not-ta-&lt;key-tag-of-KSK-current&gt;". This
          is also a validly-signed name. Any validly-signed DNS zone
          can be used for this test.</t>

          <t>A query name containing the left-most label
          "root-key-sentinel-is-ta-&lt;key-tag-of-KSK-new&gt;". This
          corresponds to a a validly-signed RRset in the zone, so that
          responses associated with queried names in this zone can be
          authenticated by a DNSSEC-validating resolver. Any
          validly-signed DNS zone can be used for this test.</t>

        </list></t>

        <t>The responses received from queries to resolve each of
        these names can be evaluated to infer a trust key state of the
        user's DNS resolution envirionment.</t>

        <t>We will describe the responses to these queries using a
        simplified notation. Each query will either result in a
        SERFVAIL response, indicating that all of the resolvers in the
        recursive resolver set returned the SERVFAIL response code,
        which we will denote here using the code "S", or result in a
        response with the desire RRset value, which we will denote
        using the code "A". If we order the queries with the "invalid"
        name, the "not-ta" label, then the "is-ta" label, then we can
        use a triplet ntation to denote a particular response. For
        example, the triplet "(S S A)" denotes a SERVFAIL response to
        the invalid query, a SERVFAIL response to the "not-ta" query
        and a RRset response to the "is-ta" query.</t>

        <t>The set of all possible responses to these three queries
        are:</t>

        <t><list style="hanging">
          <t hangText="(A * *)"> If any resolver returns an "A"
          response to the the first (invalid name) query then the
          resolver set contains at least one non-validating DNS
          resolver, and the user will not be impacted by the KSK
          roll.</t>

          <t hangText="(S A *)"> If any of the resolvers returns an
          "A" response the the "not-ta" query then at lease one od the
          resolvers does not recognse the sentinel mechanism, and the
          behaviour of the collection of resolvers during the KSK roll
          cannot be reliably determined.</t>

          <t hangText="(S S A)"> This case imnplies that all of the
          resolvers in the set perform DNSSEC-validation, all of the
          resolvers are aware of the sentinel mechanism, and at least
          one resolver has loaded KSK-new as a local trust anchor. The
          user will not be impacted by the KSK roll.</t>

          <t hangText="(S S S)"> This case imnplies that all of the
          resolvers in the set perform DNSSEC-validation, all of the
          resolvers are aware of the sentinel mechanism, and none of
          the resolvers has loaded KSK-new as a local trust
          anchor. The user will be negatively impacted by the KSK
          roll.</t> 
        </list></t>

      </section>
    </section>

    <section title="Security Considerations">
      <t>This document describes a mechanism to allow users to
      determine the trust anchor state of root zone key signing keys
      in the DNS resolution system that they use. If the user executes
      third party code, then this information may also be available to
      the third party.</t>

      <t>The mechanism does not require resolvers to set otherwise
      unauthenticated responses to be marked as authenticated, and does not
      alter the security properties of DNSSEC with respect to the
      interpretation of the authenticity of responses that are so marked.</t>

      <t>The mechanism does not require any further significant processing of
      DNS responses, and queries of the form described in this document do not
      impose any additional load that could be exploited in an attack over the
      the normal DNSSEC validation processing load.</t>
    </section>

    <section title="Privacy Considerations">
      <t>The mechanism in this document enables third parties (with either
      good or bad intentions) to learn something about the security
      configuration of recursive DNS resolvers. That is, someone who can cause
      an Internet user to make specific DNS queries (e.g. via web-based
      advertisements or javascript in web pages), can, under certain specific
      circumstances that includes additional knowledge of the resolvers that
      are invoked by the user, determine which trust anchors are configured in
      these resolvers. Without this additional knowledge, the third party can
      infer the aggregate capabilities of the user's DNS resolution
      environment, but cannot necessarily infer the trust configuration of any
      recursive name server.</t>
    </section>

    <section title="Implementation Experience">
      <t>Petr Spacek implemented early versions of this technique into the
      Knot resolver, and identified a number of places where it wasn't clear,
      and provided very helpful text to address this.</t>

      <t>Ondrej Sury of ISC has reported to the DNSOP Working Group in April
      2018 that this technique was peer-reviewed and merged into BIND master
      branch with the intent to backport the feature into older release
      branches.</t>

      <t>Benno Overeinder of NLnet Labs reported to the DNSOP Working Group in
      April 2018 an intention to support this technique in Unbound in the near
      future.</t>

      <t>An implementation of the client side of this protocol is available
      at: http://www.ksk-test.net</t>
    </section>

    <section title="IANA Considerations">
      <t>[Note to IANA, to be removed prior to publication: there are no IANA
      considerations stated in this version of the document.]</t>
    </section>

    <section title="Acknowledgements">
      <t>This document has borrowed extensively from <xref target="RFC8145"/>
      for the introductory text, and the authors would like to acknowledge and
      thank the authors of that document both for some text excerpts and for
      the more general stimulation of thoughts about monitoring the progress
      of a roll of the KSK of the root zone of the DNS.</t>

      <t>The authors would like to thank Joe Abley, Mehmet Akcin, Mark
      Andrews, Richard Barnes, Ray Bellis, Stephane Bortzmeyer, David Conrad,
      Ralph Dolmans, John Dickinson, Steinar Haug, Bob Harold, Wes Hardaker,
      Paul Hoffman, Matt Larson, Jinmei Tatuya, Edward Lewis, George
      Michaelson, Benno Overeinder, Matthew Pounsett, Andreas Schulze, Mukund
      Sivaraman, Petr Spacek, Job Snijders, Andrew Sullivan, Ondrej Sury, Paul
      Vixie, Duane Wessels and Paul Wouters for their helpful feedback.</t>

      <t>The authors would like to especially call out Paul Hoffman and Duane
      Wessels for providing comments in the form of a pull request.</t>
    </section>

    <section title="Change Log">
      <t>RFC Editor: Please remove this section!</t>

      <t>Note that this document is being worked on in GitHub - see Abstract.
      The below is mainly large changes, and is not authoritative.</t>

      <t>From -12 to -13:<list style="symbols">
          <t>Merged Paul Hoffmans PR#19, PR#20.</t>

          <t>Moved toy ksk-test.net to implmentation section.</t>

          <t>Split the test procedures between the test of a single DNS resolvers
          and the test of a collection of DNS resolvers as would be found in an
          end user environment.</t>
        </list></t>

      <t>From -11 to -12:<list style="symbols">
          <t>Moved the Walkthrough Example to the end of the document as an
          appendix.</t>

          <t>Incorporated changes as proposed by Ondrej Sury, relating to a
          consistent use of Key Tag and a reference to the definition of a
          Bogus RRset.</t>

          <t>Corrected minor typos.</t>

          <t>Revised the Privacy Considerations.</t>

          <t>In response to a request from DNSOP Working Group chairs, a
          section on reported Implementation Experience has been added, based
          on postings to the DNSOP Working Group mailing list.</t>
        </list></t>

      <t>From -10 to -11:<list style="symbols">
          <t>Clarified the preconditions for this mechanism as per Working
          Group mailing list discussion.</t>

          <t>Corrected minor typo.</t>
        </list></t>

      <t>From -09 to -10:<list style="symbols">
          <t>Clarified the precondition list to specify that the resolver had
          performed DNSSEC-validation by setting the AD bit in the
          response</t>

          <t>Clarified the language referring to the operation of RFC8145
          signalling.</t>
        </list></t>

      <t>From -08 to -09:<list style="symbols">
          <t>Incorporated Paul Hoffman's PR # 15 (Two issues from the
          Hackathon) -
          https://github.com/APNIC-Labs/draft-kskroll-sentinel/pull/15</t>

          <t>Clarifies that the match is on the *original* QNAME.</t>
        </list></t>

      <t>From -08 to -07:<list style="symbols">
          <t>Changed title from "A Sentinel for Detecting Trusted Keys in
          DNSSEC" to "A Root Key Trust Anchor Sentinel for DNSSEC".</t>

          <t>Changed magic string from "kskroll-sentinel-" to
          "root-key-sentinel-" -- this time for sure, Rocky!</t>
        </list></t>

      <t>From -07 to -06:<list style="symbols">
          <t>Addressed GitHub PR #14: Clarifications regarding caching and
          SERVFAIL responses</t>

          <t>Addressed GitHub PR #12, #13: Clarify situation with multiple
          resolvers, Fix editorial nits.</t>
        </list></t>

      <t>From -05 to -06:<list style="symbols">
          <t>Paul improved my merging of Petr's text to make it more readable.
          Minor change, but this is just before the cut-off, so I wanted it
          maximally readable.</t>
        </list></t>

      <t>From -04 to -05: <list style="symbols">
          <t>Incorporated Duane's #10</t>

          <t>Integrated Petr Spacek's Issue -
          https://github.com/APNIC-Labs/draft-kskroll-sentinel/issues/9 (note
          that commit-log incorrectly referred to Duane's PR as number 9, it
          is actually 10).</t>
        </list></t>

      <t>From -03 to -04:<list style="symbols">
          <t>Addressed GitHub pull requests #4, #5, #6, #7 #8.</t>

          <t>Added Duane's privacy concerns</t>

          <t>Makes the use cases clearer</t>

          <t>Fixed some A/AAAA stuff</t>

          <t>Changed the example numbers</t>

          <t>Made it clear that names and addresses must be real</t>
        </list></t>

      <t>From -02 to -03:<list style="symbols">
          <t>Integrated / published comments from Paul in GitHub PR #2 -
          https://github.com/APNIC-Labs/draft-kskroll-sentinel/pull/2</t>

          <t>Made the Key Tag be decimal, not hex (thread / consensus in
          https://mailarchive.ietf.org/arch/msg/dnsop/Kg7AtDhFRNw31He8n0_bMr9hBuE
          )</t>
        </list></t>

      <t>From -01 to 02:<list style="symbols">
          <t>Removed Address Record definition.</t>

          <t>Clarified that many things can cause SERVFAIL.</t>

          <t>Made examples FQDN.</t>

          <t>Fixed a number of typos.</t>

          <t>Had accidentally said that Charlie was using a non-validating
          resolver in example.</t>

          <t>[ TODO(WK): Doc says Key Tags are hex, is this really what the WG
          wants? ]</t>

          <t>And active key is one that can be used *now* (not e.g
          AddPend)</t>
        </list></t>

      <t>From -00 to 01:<list style="symbols">
          <t>Added a conversational description of how the system is intended
          to work.</t>

          <t>Clarification that this is for the root.</t>

          <t>Changed the label template from _is-ta-&lt;key-tag&gt; to
          kskroll-sentinel-is-ta-&lt;key-tag&gt;. This is because BIND (at
          least) will not allow records which start with an underscore to have
          address records (CNAMEs, yes, A/AAAA no). Some browsers / operating
          systems also will not fetch resources from names which start with an
          underscore.</t>
        </list></t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='https://xml2rfc.tools.ietf.org/public/rfc/bibxml-rfcs/reference.RFC.2308.xml'?>

      <?rfc include='https://xml2rfc.tools.ietf.org/public/rfc/bibxml-rfcs/reference.RFC.4033.xml'?>

      <?rfc include='https://xml2rfc.tools.ietf.org/public/rfc/bibxml-rfcs/reference.RFC.4034.xml'?>

      <?rfc include='https://xml2rfc.tools.ietf.org/public/rfc/bibxml-rfcs/reference.RFC.4035.xml'?>

      <?rfc include='https://xml2rfc.tools.ietf.org/public/rfc/bibxml-rfcs/reference.RFC.5011.xml'?>
    </references>

    <references title="Informative References">
      <?rfc include='https://xml2rfc.tools.ietf.org/public/rfc/bibxml-rfcs/reference.RFC.8145.xml'?>
    </references>

    <section title="Protocol Walkthrough Example">
      <t>This Appendix provides a non-normative example of how the sentinel
      mechanism could be used, and what each participant does. It is provided
      in a conversational tone to be easier to follow.
      The examples here all assume that each person has just one resolver,
      or a system of resolvers that have the same properties.</t>

      <t>Alice is in charge of the DNS root KSK (Key Signing Key), and would
      like to roll / replace the key with a new one. She publishes the new
      KSK, but would like to be able to predict / measure what the impact will
      be before removing/revoking the old key. The current KSK has a Key Tag
      of 11112, the new KSK has a Key Tag of 02323. Users want to verify that
      their resolver will not break after Alice rolls the root KSK key (that
      is, starts signing with just the KSK whose Key Tag is 02323).</t>

      <t>Bob, Charlie, Dave, Ed are all users. They use the DNS recursive
      resolvers supplied by their ISPs. They would like to confirm that their
      ISPs have picked up the new KSK. Bob's ISP does not perform validation.
      Charlie's ISP does validate, but the resolvers have not yet been
      upgraded to support this mechanism. Dave and Ed's resolvers have been
      upgraded to support this mechanism; Dave's resolver has the new KSK,
      Ed's resolver hasn't managed to install the 02323 KSK in its trust store
      yet.</t>

      <t>Geoff is a researcher, and would like to both provide a means for
      Bob, Charlie, Dave and Ed to be able to perform tests, and also would
      like to be able to perform Internet-wide measurements of what the impact
      will be (and report this back to Alice).</t>

      <t>Geoff sets an authoritative DNS server for example.com, and also a
      webserver (www.example.com). He adds three address records to
      example.com: <list>
          <t>bogus.example.com. IN AAAA 2001:db8::1</t>

          <t>root-key-sentinel-is-ta-02323.example.com. IN AAAA
          2001:db8::1</t>

          <t>root-key-sentinel-not-ta-11112.example.com. IN AAAA
          2001:db8::1</t>
        </list></t>

      <t>Note that the use of "example.com" names and the addresses here are
      examples. In a real deployment, the domain names need to be under
      control of the researcher, and the addresses must be real, reachable
      addresses.</t>

      <t>Geoff then DNSSEC signs the example.com zone, and intentionally makes
      the bogus.example.com record have bogus validation status (for example, by editing
      the signed zone and entering garbage for the signature). Geoff also
      configures his webserver to listen on 2001:db8::1 and serve a resource
      (for example, a 1x1 GIF, 1x1.gif) for all of these names. The webserver
      also serves a webpage (www.example.com) which contains links to these 3
      resources (http://bogus.example.com/1x1.gif,
      http://root-key-sentinel-is-ta-02323.example.com/1x1.gif,
      http://root-key-sentinel-not-ta-11112.example.com/1x1.gif).</t>

      <t>Geoff then asks Bob, Charlie, Dave and Ed to browse to
      www.example.com. Using the methods described in this document, the users
      can figure out what their fate will be when the 11112 KSK is
      removed.</t>

      <t>Bob is not using a validating resolver. This means that he will be
      able to resolve bogus.example.com (and fetch the 1x1 GIF) - this tells
      him that the KSK roll does not affect him, and so he will be OK.</t>

      <t>Charlie's resolvers are validating, but they have not been
      upgraded to support the KSK sentinel mechanism. Charlie will not
      be able to fetch the http://bogus.example.com/1x1.gif resource
      (the bogus.example.com record is bogus, and none of his
      resolvers will resolve it). He is able to fetch both of the
      other resources - from this he knows (see the logic in the body
      of this document) that he is using validating resolvers, but at
      least one of these resolvers is not configured to perform
      sentinel processing. The KSK sentinel method cannot provide him
      with a definitive answer to the question of whether he will be
      impacted by the KSK roll.</t>

      <t>Dave's resolvers implement the sentinel method, and have
      picked up the new KSK. For the same reason as Charlie, he cannot
      fetch the "bogus" resource. His resolver resolves the
      root-key-sentinel-is-ta-02323.example.com name normally (it
      contacts the example.com authoritative servers, etc); as it
      supports the sentinel mechanism, just before Dave's recursive
      resolver sends the reply to Dave's stub, it performs the KSK
      Sentinel check. The QNAME starts with
      "root-key-sentinel-is-ta-", and the recursive resolver does
      indeed have a key with the Key Tag of 02323 in its root trust
      store. This means that that this part of the KSK Sentinel check
      passes (it is true that Key Tag 02323 is in the trust anchor
      store), and the recursive resolver replies normally (with the
      answer provided by the authoritative server). Dave's recursive
      resolver then resolves the
      root-key-sentinel-not-ta-11112.example.com name. Once again, it
      performs the normal resolution process, but because it
      implements KSK Sentinel (and the QNAME starts with
      "root-key-sentinel-not-ta-"), just before sending the reply, it
      performs the KSK Sentinel check. As it has the key with key-tag
      11112 in it's trust anchor store, the answer to "is this *not* a
      trust anchor" is false, and so the recursive resolver does not
      reply with the answer from the authoritative server - instead,
      it replies with a SERVFAIL (note that replying with SERVFAIL
      instead of the original answer is the only mechanism that KSK
      Sentinel uses). This means that Dave cannot fetch "bogus", he
      can fetch "root-key-sentinel-is-ta-02323", but he cannot fetch
      "root-key-sentinel-not-ta-11112". From this, Dave knows that he
      is behind an collection of resolvers that all validate, all have
      the key with key tag 11112 loaded and at least one of these
      resolvers has loaded the key with key-tag 02323 into its local
      trust anchor cache, Dave will not be impacted by the KSK
      roll.</t>

      <t>Just like Charlie and Dave, Ed cannot fetch the "bogus"
      record.  This tells him that his resolvers are validating. When
      his (sentinel-aware) resolvers performs the KSK Sentinel check for
      "root-key-sentinel-is-ta-02323", none of them have loaded the
      new key with key-tag 02323 in their local trust anchor
      store. This means check fails, and Ed's recursive resolver
      converts the (valid) answer into a SERVFAIL error response. It
      performs the same check for
      root-key-sentinel-not-ta-11112.example.com, and as all of Ed's
      resolvers both perform DNSSEC validation and recognise the
      sentinel label Ed will be unable to fetch the
      "root-key-sentinel-not-ta-11112" resource. This tells Ed that
      his resolvers have not installed the new KSK and he will be
      negatively implacted by the KSK roll..</t>

      <t>Geoff would like to do a large scale test and provide the information
      back to Alice. He uses some mechanism such as causing users to go to a
      web page to cause a large number of users to attempt to resolve the
      three resources, and then analyzes the results of the tests to determine
      what percentage of users will be affected by the KSK rollover event.</t>

      <t>This description is a simplified example - it is not anticipated that
      Bob, Charlie, Dave and Ed will actually look for the absence or presence
      of web resources; instead, the webpage that they load would likely
      contain JavaScript (or similar) which displays the result of the tests,
      sends the results to Geoff, or both. This sentinel mechanism does not
      rely on the web: it can equally be used by trying to resolve the names
      (for example, using the common "dig" command) and checking which result
      in a SERVFAIL.</t>
    </section>
  </back>
</rfc>
